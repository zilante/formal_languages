  Сначала построим НКА для регулярного выражения, заданного в обратной польской 

записи. Для этого начнем обходить его слева направо. Если встречаем символ '1',

'a', 'b' или 'c', то строим НКА (строим как на семинаре) для этого символа и кладем 
этот НКА на стек. Если встречаем оператор '+', '*' или '.', то применяем его к 
соответствующим операндам со стека (новый НКА строим как на семинаре). Результат 
кладем на стек (операнды убираем со стека).

В конце на стеке должен остаться единственный НКА, он и будет искомым.

Если встречаем символ, отличный от перечисленных выше, или не хватает операндов

для оператора, или в конце на стеке не один НКА, то рег. выражение некорректно.

  После построения НКА можно решить исходную задачу. Для этого попытаемся считать

x^k (x - буква из условия задачи, k - нат. число из условия задачи). Если не 

удастся, значит слова с префиксом x^k не выводятся в языке, задаваемом рег.

выражением. Иначе будем считывать след. символы по НКА, пока не придем в

терминальное состояние в НКА. После того, как обнаружим первое терминальное

состояние, получим ответ. Осталось понять, почему мы всегда в таком случае придем

в терминальное состояние. Докажем это по индукции:

База. В НКА для символов 'a', 'b', 'c', '1' все верно.

Шаг. При применении '+' что-то может испортиться только для нового нач. состояния.

Но так как оно переходит в старые состояния, то из него по-прежнему можно добраться

до терминальных.

    При применении '.' что-то может испортиться только для вершин первого НКА, если 
после применения оператора его терминальные стали нетерминальными.  Но эти 

бывшие терминальные состояния переходят в состояния второго НКА, значит из них снова 

достижимы терминальные состояния, а значит и из всех состояний первого НКА.

    При применении '*' новое состояние сразу является терминальным, поэтому здесь

инвариант также соблюден.


Опишем подробнее, как мы находим длину кратчайшего слова, начнающегося с префикса

x^k.

Начинаем обход построеннго автомата из начальной вершины. На первом шаге

находим все вершины, в которые можно перейти из начальной вершины по x.

На n-м шаге находим все вершины, в которые можно перейти по x из вершин,

которые были найдены на (n - 1)-м шаге.

Если на каком-то шаге до k-го включительно не удалось найти таких вершин,

то слова, начинающиеся с x^k, не считываются автоматом, а значит они не

задаются регулярным выражением.

Иначе, будем двигаться из вершин k-го шага по всем возможным буквам.

Затем из вершин, найденных на предыдущем шаге и т.д. Т.е. запустим BFS,

который остановим при нахождении первой терминальной вершины.

Временная сложность такого алгоритма - O(E * l), где E - кол-во ребер в автомате,

l - длина искомого кратчайшего слова.

Осталось оценить число E.

Пусть длина рег. выражения - n.

Тогда заметим, что при обработке очередного символа рег. выражения появляется

не больше 2-ух новых вершин. Тогда в итоге получим не больше 2 * n вершин.

А значит кол-во всевозможных ребер - не больше 4 * n^2 * 3, т.е. O(n^2).

Значит временная сложность составляет O(n^2 * l).